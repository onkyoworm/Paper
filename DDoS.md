这是一个很有趣的东西</br>
看了这么多 分类基本上是分为这两种		
	
	1、 带宽消耗型攻击
		很容易理解 消耗的是物理带宽 造成的是请求无法去到服务器
	2、 资源消耗型攻击
		资源 主要指的是服务器的资源 例如内存 cpu等 造成的是服务器来不及处理请求
分类 这里的分类以上面的分类为主</br>
    `消耗带宽型的攻击`</br>
    `消耗资源类型的攻击`</br>
    `消耗DNS解析请求的攻击`</br>
</br>
</br>
</br>
先说一下`带宽消耗类型的攻击`</br>
顾名思义 这类型的攻击主要是针对带宽的</br>
具体有哪些?	
	
	SYN Flood攻击
	ACK Flood攻击
	UDP Flood攻击
	ICMP Flood攻击
	Connection Flood攻击
	等等 以后继续补充
说一下比较常见的`SYN Flood`吧</br>
说起`SYN`就不得不提`TCP/IP 协议簇`</br>
这里不着重说`TCP/IP 协议簇`的事情 说以我们直接说三次握手的事情</br>
本来打算灵魂画手一波的 想想还是用图吧</br>
![](https://i.imgur.com/CmP6JXh.png)</br>
首先 `TCP`是一个有连接的协议(保证数据高效、安全的进行传输) 问题就是出在了连接建立上面</br>
如上图 首先`客户端`发送一个`SYN`标志的报文 指定了客户端使用的端口以及初始序号</br>
然后`服务器端`收到后 返回一个`SYN+ACK`的报文 表示客户端的请求已被接受 同时`TCP序号`加一 </br>
最后一步 `客户端`也返回一个确认用的`ACK`报文给`服务器` 同样序列号加一 TCP连接完成 数据开始传输</br>
</br>
那么问题就出在了如果发送`SYN`以及`SYN+ACK`后 如果客户端失去了连接 那么客户端是会进行重试的并在一定时间之后才会丢弃掉这个连接(时间分钟级 称SYN Timeout) 而且服务器维持大量的半连接列表需要消耗带昂资源 同时还要对其中的IP进行`SYN + ACK`重试</br>
结果一般是堆栈溢出或是忙于处理伪造的IP请求而没办法理睬客户的正常请求</br>
解决办法</br>
如果使用修改参数的方法		
	
	net.ipv4.tcp_syncookies
	net.ipv4.tcp_max_syn_backlog
	net.ipv4.tcp_synack_retries
	SYN Timeout
一个个解析一下</br>
先说一下`SYN Cookies`吧</br>
主要是缓解服务器资源压力 网上说的好复杂 我总结一下吧</br>
不使用的情况下 服务器需要另外分配资源来保存`SYN号`之类的相关信息 启用后通过特定的算法生成`SYN号` 然后清除那些信息 在收到`ACK包`后进行匹配 通过则完成握手 失败则丢弃</br>
这样的好处是节省了提到的存储空间 同样这种方法也有对抗措施 `SYN+ ACK`攻击 后面再讨论</br>
那么`syn_backlog`是用来干嘛的 这个你可以理解为向服务器借空间来用 打个比方 如果设置的等待队列最长的`50000`个 每个要占用`1kb`的大小 当快接近极限容量的时候可以向服务器借内存资源扩大这个队列的空间</br>
简而言之是`是使用服务器的内存资源，换取更大的等待队列长度，让攻击数据包不至于占满所有连接而导致正常用户无法完成握手`</br>
那么`synack_retries`呢? 则是设置服务器`SYN+ACK`报文发送的重试次数</br>
    `SYN Timeout`这个很容易理解 从接受SYN报文到确定这个报文无效并丢弃该连接的时间</br>
先说`ACK Flood` 等下再说`SYN+ACK`的情况</br>
    `ACK Flood`的话是出现在建立连接之后 正常下 每个`TCP`报文都带有`ACK`标志位的 会检查里面的四元组是否存在以及状态是否合法 然后在向应用层传递该数据包(猜猜 四元组 五元组 七元组都是什么 哈哈哈哈)</br>
如果这个ACK报文出现了问题就要回应一个RST报文 这个攻击就是利用这个原因的</br>
不过对比单个`ACK`报文和`SYN`报文出现问题后所做动作的复杂程度来看 `ACK`报文带来的负担要小得多 只有当`pps`达到一定程度后负载才会有比较大的变化 正常的数据包才可能无法得到及时处理 表现就是页面反应慢 丢包率高</br>
一般采用的是大流量ACK小包进行 理论上随机源IP的ACK小包会被server很快丢弃 但实际上测试发现有些TCP服务会对ACK Flood较为敏感(fe. JSP Server 仅供参考…… Apache IIS这个数量级以上也会出现问题 总感觉是JSP 开发人员的问题=。=)</br>
说 如果没有开放端口 服务器会直接丢弃(消耗CPU) 端口开放 会回应RST(?????有点迷糊 先看IP再看端口???)</br>
防护的话 首先你要知道 很少单独出现这个`ACK Flood`的</br>
一般进行判断 是通过对称性进行判断 收包异常大于发包(高速度发小包) 但是还是上面说的 因为和别的方法结合 很容易误判</br>
有一种应对方法: 建立一个`hash表` 用来存放TCP连接的状态(相对于tcp栈 过程简化了) 不做`seq`号的检查 不做包乱序的处理 只是统计一定时间内是否有`ACK`包在连接(四元组)上通过 从而判断该该连接是否是活动</br>
看完这个方法 有个疑问: 为什么解决办法不像是上面`SYN`这里一样 进行的是调整时间 或是向服务器接资源之类的操作 而是要去查看这个连接是否是活动? `ACK Flood`的本质不是因为`ACK`位出现了问题 导致需要额外的开销吗????